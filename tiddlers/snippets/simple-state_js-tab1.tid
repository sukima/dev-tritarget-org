modified: 20191206115412000
created: 20191206042911000
creator: Sukima
modifier: Sukima
title: simple-state_js-tab1
tags: [[Simple State Machine]]
type: application/javascript
caption: StateMachine Class

function createMachine(
  { context = {}, id, initial, states = {} } = {},
  { actions = {}, guards = {} } = {}
) {
  function stateFor({ target }, stateContext = context, changed) {
    if (!target) { return; }
    let { meta = {} } = states[target] || {};
    let newContext = { ...stateContext };
    return { value: target, meta, context: newContext, changed, actions: [] };
  }
  function findStateEvent(transitionData, eventData, stateContext = context) {
    for (let transition of [].concat(transitionData)) {
      if (!transition) { continue; }
      let { target = transition, cond = () => true } = transition;
      if (typeof target !== 'string') { target = ''; }
      let stateEvent = { ...eventData, target };
      if (typeof cond === 'function') {
        if (cond(stateContext, stateEvent)) { return stateEvent; }
        continue;
      }
      if (guards[cond](stateContext, stateEvent)) { return stateEvent; }
    }
    return {};
  }
  function boundAction(type, event, state) {
    return function(action) {
      if (!action) { return; }
      if (!action.exec) { action = { exec: action }; }
      if (typeof action.exec !== 'function') { action.exec = actions[action.exec]; }
      let exec = action.exec && ((...args) => action.exec(state.context, event, { action, state }, ...args));
      return { type: (action.type || type), exec };
    };
  }
  return {
    id, initialState: stateFor({ target: initial }, context, false),
    transition(state, transitionEvent) {
      let currentValue = (state && state.value) || state;
      let stateConfig = states[currentValue];
      if (!stateConfig) {
        throw new Error(`State '${currentValue}' not found on machine${id ? ` ${id}` : ''}`);
      }
      let { type = transitionEvent, value } = transitionEvent;
      let transitions = stateConfig.on || {};
      let transition = transitions[type] || {};
      let stateEvent = findStateEvent(transition, { type, value }, state.context);
      let nextState = stateEvent.target && stateEvent.target !== currentValue
        ? stateFor(stateEvent, state.context, true)
        : stateFor({ target: currentValue }, state.context, false);
      nextState.actions = [].concat(transition.actions || []).map(boundAction('action', stateEvent, nextState));
      if (nextState.changed) {
        let targetConfig = states[stateEvent.target] || {};
        nextState.actions.unshift(...[].concat(stateConfig.exit || []).map(boundAction('exit', stateEvent, nextState)));
        nextState.actions.push(...[].concat(targetConfig.entry || []).map(boundAction('entry', stateEvent, nextState)));
      }
      nextState.actions = nextState.actions.filter(action => !!action);
      return nextState;
    },
  };
}
