modified: 20191206115412000
created: 20191206042911000
creator: Sukima
modifier: Sukima
title: simple-state_js-tab1
tags: [[Simple State Machine]]
type: application/javascript
caption: StateMachine Class

function createMachine(
  { context = {}, id, initial, states = {} } = {},
  { actions = {}, guards = {} } = {}
) {
  function stateFor({ target }, stateContext = context, changed) {
    if (!target) { return; }
    let { meta = {} } = states[target] || {};
    let newContext = { ...stateContext };
    return { value: target, meta, context: newContext, changed };
  }
  function findStateEvent(transitionData, eventData) {
    if (!transitionData) { return; }
    for (let transition of [].concat(transitionData)) {
      if (!transition) { continue; }
      let { target = transition, cond = () => true } = transition;
      let stateEvent = { ...eventData, target };
      if (typeof cond === 'function') {
        if (cond(context, stateEvent)) { return stateEvent; }
        continue;
      }
      if (guards[cond](context, stateEvent)) { return stateEvent; }
    }
  }
  function boundAction(type, event, ctx) {
    return function(action) {
      if (!action) { return; }
      if (typeof action !== 'function') { action = actions[action]; }
      let exec = action && ((...args) => action(ctx, event, ...args));
      return { type, exec };
    };
  }
  return {
    initialState: stateFor({ target: initial }, context, false),
    transition(state, transitionEvent) {
      let currentValue = (state && state.value) || state;
      let stateConfig = states[currentValue];
      if (!stateConfig) {
        throw new Error(`State '${currentValue}' not found on machine${id ? ` ${id}` : ''}`);
      }
      let { type = transitionEvent, value } = transitionEvent;
      let transitions = stateConfig.on || {};
      let transition = transitions[type];
      let stateEvent = findStateEvent(transition, { type, value });
      let nextState = stateEvent
        ? stateFor(stateEvent, state.context, true)
        : stateFor({ target: currentValue }, state.context, false);
      if (nextState.changed) {
        let targetStateConfig = states[stateEvent.target] || {};
        nextState.actions = [
          boundAction('exit', stateEvent, nextState.context)(stateConfig.exit),
          ...(transition.actions || []).map(boundAction('action', stateEvent, nextState.context)),
          boundAction('entry', stateEvent, nextState.context)(targetStateConfig.entry),
        ].filter(action => !!action);
      }
      return nextState;
    },
  };
}
